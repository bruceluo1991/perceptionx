import sys
import pytest
import numpy as np
from scipy.spatial.transform import Rotation
from qs_datasets.nuscenes.pose import Pose

'''
These unit tests are generated by ChatGPT, and with a little effort to rectified.
'''

def test_init_with_ndarray_and_rotation():
    quat = np.array([1, 0, 0, 0])  # identity
    t = np.array([0, 0, 0])

    p1 = Pose(quat, t)
    p2 = Pose(Rotation.from_quat([0, 0, 0, 1]), t)  # same identity rotation

    assert np.allclose(p1.r.as_matrix(), np.eye(3))
    assert np.allclose(p2.r.as_matrix(), np.eye(3))


def test_repr_contains_quat_and_t():
    quat = np.array([1, 0, 0, 0])
    t = np.array([1, 2, 3])
    p = Pose(quat, t)
    s = repr(p)
    assert "quat" in s
    assert "t" in s


def test_transform_and_inverse_transform():
    # 90° rotation around z-axis
    quat = Rotation.from_euler("z", 90, degrees=True)
    t = np.array([1, 2, 3])
    p = Pose(quat, t)

    point = np.array([1, 0, 0])
    tp = p.transform(point)
    ip = p.transform_inv(tp)

    assert np.allclose(ip, point)


def test_inv_pose_property():
    quat = Rotation.from_euler("z", 45, degrees=True)
    t = np.array([1, 0, 0])
    p = Pose(quat, t)

    x = np.array([2, 3, 4])
    y = p.transform(x)
    x_back = p.inv().transform(y)

    assert np.allclose(x_back, x)


def test_compose_equivalence():
    # First rotate 90° around z, then translate
    p1 = Pose(Rotation.from_euler("z", 90, degrees=True), np.array([1, 0, 0]))
    p2 = Pose(Rotation.from_euler("x", 90, degrees=True), np.array([0, 1, 0]))

    point = np.array([1, 0, 0])
    composed = p1.compose(p2).transform(point)
    sequential = p1.transform(p2.transform(point))

    assert np.allclose(composed, sequential)


def test_compose_with_inverse_is_identity():
    quat = Rotation.from_euler("y", 30, degrees=True)
    t = np.array([0.5, -1, 2])
    p = Pose(quat, t)
    pid = p.compose(p.inv())

    point = np.array([1.2, 3.4, -0.5])
    out = pid.transform(point)

    assert np.allclose(out, point)


def test_edge_cases_identity():
    # Identity rotation and zero translation
    quat = np.array([1, 0, 0, 0])
    t = np.zeros(3)
    p = Pose(quat, t)

    point = np.array([1, 2, 3])
    tp = p.transform(point)

    assert np.allclose(tp, point)
    assert np.allclose(p.inv().transform(point), point)


def test_transform_identity():
    # 单位旋转 + 零平移
    quat = np.array([1, 0, 0, 0])  # identity
    t = np.array([0, 0, 0])
    p = Pose(quat, t)

    inp = np.array([1, 2, 3])
    out = p.transform(inp)

    expected = np.array([1, 2, 3])
    assert np.allclose(out, expected)


def test_transform_translation_only():
    # 单位旋转 + 平移
    quat = np.array([1, 0, 0, 0])  # identity
    t = np.array([1, -2, 3])
    p = Pose(quat, t)

    inp = np.array([0, 0, 0])
    out = p.transform(inp)

    expected = np.array([1, -2, 3])
    assert np.allclose(out, expected)


def test_transform_rotation_90_z():
    # 绕 z 轴逆时针 90° + 平移 (1,2,3)
    quat = Rotation.from_euler("z", 90, degrees=True)
    t = np.array([1, 2, 3])
    p = Pose(quat, t)

    inp = np.array([1, 0, 0])  # x 轴方向
    out = p.transform(inp)

    # 旋转后 (1,0,0) -> (0,1,0)，再加平移 (1,2,3)
    expected = np.array([1, 3, 3])
    assert np.allclose(out, expected)


def test_transform_rotation_180_x():
    # 绕 x 轴 180° + 平移 (0,0,1)
    quat = Rotation.from_euler("x", 180, degrees=True)
    t = np.array([0, 0, 1])
    p = Pose(quat, t)

    inp = np.array([0, 1, 2])
    out = p.transform(inp)

    # 旋转后 (0,1,2) -> (0,-1,-2)，再加 (0,0,1)
    expected = np.array([0, -1, -1])
    assert np.allclose(out, expected)


def test_transform_multiple_points():
    # 绕 y 轴 90° + 平移 (1,0,0)
    quat = Rotation.from_euler("y", 90, degrees=True)
    t = np.array([1, 0, 0])
    p = Pose(quat, t)

    points = np.array(
        [
            [1, 0, 0],  # x轴点
            [0, 0, 1],  # z轴点
        ]
    )
    out = np.array([p.transform(pt) for pt in points])

    # (1,0,0) -> (0,0,-1)，+ (1,0,0) = (1,0,-1)
    # (0,0,1) -> (1,0,0)，  + (1,0,0) = (2,0,0)
    expected = np.array(
        [
            [1, 0, -1],
            [2, 0, 0],
        ]
    )
    assert np.allclose(out, expected)


def test_transform_rotation_30deg_z():
    # 绕 z 轴顺时针 30°，再平移 (1,2,0)
    quat = Rotation.from_euler("z", -30, degrees=True)
    t = np.array([1, 2, 0])
    p = Pose(quat, t)

    inp = np.array([np.sqrt(3), 1, 0])  # (√3, 1, 0)
    out = p.transform(inp)

    # 手算旋转：Rz(-30°) * (√3, 1, 0) = (2, 0, 0)
    # 再加 t = (1, 2, 0) => (3, 2, 0)
    expected = np.array([3, 2, 0])
    assert np.allclose(out, expected)


def test_transform_rotation_45deg_x():
    # 绕 x 轴逆时针 45°，再平移 (0, 1, 2)
    quat = Rotation.from_euler("x", 45, degrees=True)
    t = np.array([0, 1, 2])
    p = Pose(quat, t)

    inp = np.array([0, 1, 1])  # (0, 1, 1)
    out = p.transform(inp)

    # 手算旋转：Rx(45°) * (0,1,1) = (0, 0, √2)
    # 再加 (0,1,2) = (0, 1 , 2 + √2)
    expected = np.array([0, 1, 2 + np.sqrt(2)])
    assert np.allclose(out, expected)


def test_transform_rotation_45deg_y():
    # 绕 y 轴逆时针 45°，再平移 (2, -1, 1)
    quat = Rotation.from_euler("y", 45, degrees=True)
    t = np.array([2, -1, 1])
    p = Pose(quat, t)

    inp = np.array([1, 0, 1])  # (1, 0, 1)
    out = p.transform(inp)

    # 手算旋转：Ry(45°) * (1,0,1) = (√2, 0, 0)
    # 再加 (2,-1,1) = (2+√2, -1, 1)
    expected = np.array([2 + np.sqrt(2), -1, 1])
    assert np.allclose(out, expected)


def test_transform_rotation_30deg_x():
    # 绕 x 轴逆时针 30°，再平移 (1,1,1)
    quat = Rotation.from_euler("x", 30, degrees=True)
    t = np.array([1, 1, 1])
    p = Pose(quat, t)

    inp = np.array([0, np.sqrt(3), 1])  # (0, √3, 1)
    out = p.transform(inp)

    # 手算旋转：Rx(30°) * (0, √3, 1)
    # = (0, (√3)(√3/2) - 1/2, (√3)(1/2) + (√3/2))
    # = (0, 3/2 - 0.5, √3/2 + √3/2)
    # = (0, 1.0, √3)
    # 再加 t=(1,1,1) => (1,2,1+√3)
    expected = np.array([1, 2, 1 + np.sqrt(3)])

    assert np.allclose(out, expected)


if __name__ == "__main__":
    sys.exit(pytest.main(sys.argv))
